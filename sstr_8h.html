<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>json-gen-c: src/utils/sstr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<a href="https://github.com/zltl/json-gen-c" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">json-gen-c
   &#160;<span id="projectnumber">0.1.5</span>
   </div>
   <div id="projectbrief">json-gen-c generate C code for json manipulation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('sstr_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sstr.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>sstr_t are objects that represent sequences of characters.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for sstr.h:</div>
<div class="dyncontent">
<div class="center"><img src="sstr_8h__incl.png" border="0" usemap="#asrc_2utils_2sstr_8h" alt=""/></div>
<map name="asrc_2utils_2sstr_8h" id="asrc_2utils_2sstr_8h">
<area shape="rect" title="sstr_t are objects that represent sequences of characters." alt="" coords="36,5,148,31"/>
<area shape="rect" title=" " alt="" coords="5,79,80,104"/>
<area shape="poly" title=" " alt="" coords="86,33,61,69,56,66,82,29"/>
<area shape="rect" title=" " alt="" coords="104,79,179,104"/>
<area shape="poly" title=" " alt="" coords="102,29,128,66,123,69,98,33"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="sstr_8h__dep__incl.png" border="0" usemap="#asrc_2utils_2sstr_8hdep" alt=""/></div>
<map name="asrc_2utils_2sstr_8hdep" id="asrc_2utils_2sstr_8hdep">
<area shape="rect" title="sstr_t are objects that represent sequences of characters." alt="" coords="482,5,594,31"/>
<area shape="rect" href="gencode_8c.html" title="JSON code generation implementation." alt="" coords="86,225,257,251"/>
<area shape="poly" title=" " alt="" coords="469,29,350,44,212,69,147,86,89,106,44,128,15,154,9,166,10,177,16,187,27,196,61,212,102,223,100,228,59,217,25,201,12,191,5,179,4,165,10,150,41,124,87,101,145,81,211,64,349,39,468,23"/>
<area shape="rect" href="gencode_8h.html" title="generate json manipulate codes." alt="" coords="25,152,195,177"/>
<area shape="poly" title=" " alt="" coords="469,35,385,55,295,81,204,119,133,154,130,149,201,114,293,76,384,49,468,30"/>
<area shape="rect" href="struct__parse_8c.html" title="parse struct definition file." alt="" coords="600,225,777,251"/>
<area shape="poly" title=" " alt="" coords="567,37,620,85,648,116,671,151,685,190,690,225,685,225,680,192,666,153,643,119,616,89,563,41"/>
<area shape="rect" href="struct__parse_8h.html" title="Parse struct definitions. Support scalar types(int, long, float, double, sstr_t), arrays,..." alt="" coords="449,152,627,177"/>
<area shape="poly" title=" " alt="" coords="541,45,541,152,535,152,535,45"/>
<area shape="rect" href="hash__map_8h.html" title="A simple hash_map implementation." alt="" coords="307,79,463,104"/>
<area shape="poly" title=" " alt="" coords="502,39,411,81,409,76,500,34"/>
<area shape="rect" href="io_8h.html" title="File operation helper functions for reading and writing files." alt="" coords="753,152,854,177"/>
<area shape="poly" title=" " alt="" coords="608,27,672,46,705,59,735,76,756,94,774,114,799,150,795,153,770,117,753,98,732,81,703,64,671,51,607,33"/>
<area shape="rect" href="sstr_8c.html" title="Implementation of the sstr.h header file." alt="" coords="804,79,915,104"/>
<area shape="poly" title=" " alt="" coords="603,31,808,76,807,81,602,36"/>
<area shape="poly" title=" " alt="" coords="131,186,163,223,159,227,127,190"/>
<area shape="rect" href="main_8c.html" title="Main entry point for json&#45;gen&#45;c code generator." alt="" coords="449,225,576,251"/>
<area shape="poly" title=" " alt="" coords="188,177,449,223,448,228,187,182"/>
<area shape="poly" title=" " alt="" coords="466,183,231,228,230,223,465,177"/>
<area shape="poly" title=" " alt="" coords="532,191,519,226,514,224,527,189"/>
<area shape="poly" title=" " alt="" coords="576,181,665,223,663,228,573,186"/>
<area shape="poly" title=" " alt="" coords="341,112,300,130,259,154,215,192,183,227,179,223,211,188,256,150,298,125,339,107"/>
<area shape="poly" title=" " alt="" coords="328,110,155,154,154,149,327,105"/>
<area shape="poly" title=" " alt="" coords="477,94,518,100,561,111,603,127,641,150,658,167,672,187,687,224,683,226,667,190,654,170,638,154,600,132,559,116,517,105,476,99"/>
<area shape="poly" title=" " alt="" coords="423,107,514,149,512,154,420,112"/>
<area shape="rect" href="hash__map_8c.html" title="Implementation of a simple hash map data structure." alt="" coords="270,152,425,177"/>
<area shape="poly" title=" " alt="" coords="374,117,356,153,351,151,370,115"/>
<area shape="poly" title=" " alt="" coords="744,183,560,228,559,223,743,178"/>
<area shape="poly" title=" " alt="" coords="775,187,709,227,706,223,772,182"/>
<area shape="rect" href="io_8c.html" title="Implementation of file I/O helper functions." alt="" coords="801,225,901,251"/>
<area shape="poly" title=" " alt="" coords="821,187,846,224,841,227,817,190"/>
</map>
</div>
</div>
<p><a href="sstr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsstr__s.html">sstr_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal structure for sstr_t implementation.  <a href="structsstr__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a97298722eedb753e63ca6742d6d07dea" id="r_a97298722eedb753e63ca6742d6d07dea"><td class="memItemLeft" align="right" valign="top"><a id="a97298722eedb753e63ca6742d6d07dea" name="a97298722eedb753e63ca6742d6d07dea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SHORT_STR_CAPACITY</b>&#160;&#160;&#160;25</td></tr>
<tr class="separator:a97298722eedb753e63ca6742d6d07dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dfcc0842363a917b93d9a23e76a4cd" id="r_a50dfcc0842363a917b93d9a23e76a4cd"><td class="memItemLeft" align="right" valign="top"><a id="a50dfcc0842363a917b93d9a23e76a4cd" name="a50dfcc0842363a917b93d9a23e76a4cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CAP_ADD_DELTA</b>&#160;&#160;&#160;256</td></tr>
<tr class="separator:a50dfcc0842363a917b93d9a23e76a4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b26ce895798f7fd4df3d6e40b0afad" id="r_a02b26ce895798f7fd4df3d6e40b0afad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#a02b26ce895798f7fd4df3d6e40b0afad">SSTR_TYPE_SHORT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a02b26ce895798f7fd4df3d6e40b0afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb2acea9cceef81b1749f5604483b54" id="r_afdb2acea9cceef81b1749f5604483b54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#afdb2acea9cceef81b1749f5604483b54">SSTR_TYPE_LONG</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:afdb2acea9cceef81b1749f5604483b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08dcbb7318a37aaebc120173cdc0b9b" id="r_ac08dcbb7318a37aaebc120173cdc0b9b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#ac08dcbb7318a37aaebc120173cdc0b9b">SSTR_TYPE_REF</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ac08dcbb7318a37aaebc120173cdc0b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f83884713d44719070e83e62639716c" id="r_a7f83884713d44719070e83e62639716c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#a7f83884713d44719070e83e62639716c">sstr_length</a>(s)&#160;&#160;&#160;((struct <a class="el" href="structsstr__s.html">sstr_s</a>*)s)-&gt;length</td></tr>
<tr class="memdesc:a7f83884713d44719070e83e62639716c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of <em>s</em>, in terms of bytes.  <br /></td></tr>
<tr class="separator:a7f83884713d44719070e83e62639716c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5290253c7b53c6a66ed07b782f68714" id="r_ad5290253c7b53c6a66ed07b782f68714"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#ad5290253c7b53c6a66ed07b782f68714">sstr_append_cstr_if</a>(dst,  src,  cond)&#160;&#160;&#160;    <a class="el" href="sstr_8c.html#a2d78409e863e5c0ba6da2ffbdcc4ff2b">sstr_append_of_if</a>(dst, src, strlen(src), cond)</td></tr>
<tr class="memdesc:ad5290253c7b53c6a66ed07b782f68714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append C style string if cond is true, otherwise do nothing.  <br /></td></tr>
<tr class="separator:ad5290253c7b53c6a66ed07b782f68714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8d28a1ce0ac6dd8b8e50af6f78e735e7" id="r_a8d28a1ce0ac6dd8b8e50af6f78e735e7"><td class="memItemLeft" align="right" valign="top"><a id="a8d28a1ce0ac6dd8b8e50af6f78e735e7" name="a8d28a1ce0ac6dd8b8e50af6f78e735e7"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><b>sstr_t</b></td></tr>
<tr class="memdesc:a8d28a1ce0ac6dd8b8e50af6f78e735e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">sstr_t are objects that represent sequences of characters. <br /></td></tr>
<tr class="separator:a8d28a1ce0ac6dd8b8e50af6f78e735e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a63e859888a3565efeac6f513cadc239e" id="r_a63e859888a3565efeac6f513cadc239e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#a63e859888a3565efeac6f513cadc239e">sstr_new</a> (void)</td></tr>
<tr class="memdesc:a63e859888a3565efeac6f513cadc239e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty sstr_t.  <br /></td></tr>
<tr class="separator:a63e859888a3565efeac6f513cadc239e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99d652d5a9d25fc79343d2ac18cb0e5" id="r_ae99d652d5a9d25fc79343d2ac18cb0e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#ae99d652d5a9d25fc79343d2ac18cb0e5">sstr_free</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s)</td></tr>
<tr class="memdesc:ae99d652d5a9d25fc79343d2ac18cb0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete a sstr_t.  <br /></td></tr>
<tr class="separator:ae99d652d5a9d25fc79343d2ac18cb0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61027cdd29e89a0a946740cc04fcba2" id="r_ad61027cdd29e89a0a946740cc04fcba2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#ad61027cdd29e89a0a946740cc04fcba2">sstr_of</a> (const void *data, size_t length)</td></tr>
<tr class="memdesc:ad61027cdd29e89a0a946740cc04fcba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sstr_t from <em>data</em> with <em>length</em> bytes.  <br /></td></tr>
<tr class="separator:ad61027cdd29e89a0a946740cc04fcba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadff88bf80c9a1d4b2911f9f19aceb03" id="r_aadff88bf80c9a1d4b2911f9f19aceb03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#aadff88bf80c9a1d4b2911f9f19aceb03">sstr_ref</a> (const void *data, size_t length)</td></tr>
<tr class="memdesc:aadff88bf80c9a1d4b2911f9f19aceb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sstr_t from data with length bytes. The data is not copied, but have a pointer to data.  <br /></td></tr>
<tr class="separator:aadff88bf80c9a1d4b2911f9f19aceb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b3c1563041f1323542f3e84f7817b1" id="r_aa3b3c1563041f1323542f3e84f7817b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#aa3b3c1563041f1323542f3e84f7817b1">sstr</a> (const char *cstr)</td></tr>
<tr class="memdesc:aa3b3c1563041f1323542f3e84f7817b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sstr_t from C-style (NULL-terminated) string <em>str</em>.  <br /></td></tr>
<tr class="separator:aa3b3c1563041f1323542f3e84f7817b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45cbd228a22432910527e63c4b26b3b" id="r_af45cbd228a22432910527e63c4b26b3b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#af45cbd228a22432910527e63c4b26b3b">sstr_cstr</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s)</td></tr>
<tr class="memdesc:af45cbd228a22432910527e63c4b26b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return C-style string representation of <em>s</em>.  <br /></td></tr>
<tr class="separator:af45cbd228a22432910527e63c4b26b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27f624aa62f1f648e96cc195da7412f" id="r_ad27f624aa62f1f648e96cc195da7412f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#ad27f624aa62f1f648e96cc195da7412f">sstr_compare</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> a, <a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> b)</td></tr>
<tr class="memdesc:ad27f624aa62f1f648e96cc195da7412f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <em>a</em> and <em>b</em> return 0 if equal, &lt;0 if <em>a</em> &lt; <em>b</em>, &gt;0 if <em>a</em> &gt; <em>b</em>.  <br /></td></tr>
<tr class="separator:ad27f624aa62f1f648e96cc195da7412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4925de2352444a8822843cbbac5ae3ed" id="r_a4925de2352444a8822843cbbac5ae3ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#a4925de2352444a8822843cbbac5ae3ed">sstr_compare_c</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> a, const char *b)</td></tr>
<tr class="memdesc:a4925de2352444a8822843cbbac5ae3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare sstr_t <em>a</em> and <em>c-style</em> string b  <br /></td></tr>
<tr class="separator:a4925de2352444a8822843cbbac5ae3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb41a505a69f235d647bec5f96165f8" id="r_affb41a505a69f235d647bec5f96165f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#affb41a505a69f235d647bec5f96165f8">sstr_append_zero</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, size_t length)</td></tr>
<tr class="memdesc:affb41a505a69f235d647bec5f96165f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append zero bytes to string (for buffer allocation)  <br /></td></tr>
<tr class="separator:affb41a505a69f235d647bec5f96165f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55b8f697e21006921e191ca25dbcec5" id="r_ab55b8f697e21006921e191ca25dbcec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#ab55b8f697e21006921e191ca25dbcec5">sstr_append_of</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, const void *data, size_t length)</td></tr>
<tr class="memdesc:ab55b8f697e21006921e191ca25dbcec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append raw data to string.  <br /></td></tr>
<tr class="separator:ab55b8f697e21006921e191ca25dbcec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8eb5ed3acc6d1f90c5097ab2f62672f" id="r_ad8eb5ed3acc6d1f90c5097ab2f62672f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#ad8eb5ed3acc6d1f90c5097ab2f62672f">sstr_append</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> dst, <a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> src)</td></tr>
<tr class="memdesc:ad8eb5ed3acc6d1f90c5097ab2f62672f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append one sstr_t to another.  <br /></td></tr>
<tr class="separator:ad8eb5ed3acc6d1f90c5097ab2f62672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0985a798ff952a68046fb594d2f3d27" id="r_aa0985a798ff952a68046fb594d2f3d27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#aa0985a798ff952a68046fb594d2f3d27">sstr_append_cstr</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> dst, const char *src)</td></tr>
<tr class="memdesc:aa0985a798ff952a68046fb594d2f3d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append C string to sstr_t.  <br /></td></tr>
<tr class="separator:aa0985a798ff952a68046fb594d2f3d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e2708071bfb86f3961788466c9192f" id="r_a87e2708071bfb86f3961788466c9192f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#a87e2708071bfb86f3961788466c9192f">sstr_dup</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s)</td></tr>
<tr class="memdesc:a87e2708071bfb86f3961788466c9192f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate <em>s</em> and return.  <br /></td></tr>
<tr class="separator:a87e2708071bfb86f3961788466c9192f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba343262041c4dc26b5c218c4cc9cb3" id="r_a5ba343262041c4dc26b5c218c4cc9cb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#a5ba343262041c4dc26b5c218c4cc9cb3">sstr_substr</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, size_t index, size_t len)</td></tr>
<tr class="memdesc:a5ba343262041c4dc26b5c218c4cc9cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get substring of <em>s</em> starting at <em>index</em> with <em>length</em> bytes.  <br /></td></tr>
<tr class="separator:a5ba343262041c4dc26b5c218c4cc9cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1410073b28bea451ab0be874d5875b" id="r_acb1410073b28bea451ab0be874d5875b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#acb1410073b28bea451ab0be874d5875b">sstr_clear</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s)</td></tr>
<tr class="memdesc:acb1410073b28bea451ab0be874d5875b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear string content to empty.  <br /></td></tr>
<tr class="separator:acb1410073b28bea451ab0be874d5875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024de0f2bca395ea91d6f8966adaedbe" id="r_a024de0f2bca395ea91d6f8966adaedbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#a024de0f2bca395ea91d6f8966adaedbe">sstr_vslprintf</a> (const char *fmt, va_list args)</td></tr>
<tr class="memdesc:a024de0f2bca395ea91d6f8966adaedbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printf-style formatting with extended format specifiers.  <br /></td></tr>
<tr class="separator:a024de0f2bca395ea91d6f8966adaedbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64cf287e39b67b4bf945b5f5344562e" id="r_ad64cf287e39b67b4bf945b5f5344562e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#ad64cf287e39b67b4bf945b5f5344562e">sstr_vslprintf_append</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> buf, const char *fmt, va_list args)</td></tr>
<tr class="memdesc:ad64cf287e39b67b4bf945b5f5344562e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append formatted text to existing string (va_list version)  <br /></td></tr>
<tr class="separator:ad64cf287e39b67b4bf945b5f5344562e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d845cc91a348545e8f6b375437de6b" id="r_ab2d845cc91a348545e8f6b375437de6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#ab2d845cc91a348545e8f6b375437de6b">sstr_printf</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:ab2d845cc91a348545e8f6b375437de6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create formatted string (printf-style with extensions)  <br /></td></tr>
<tr class="separator:ab2d845cc91a348545e8f6b375437de6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6e86f4ff2db447c525e82b88d3173e" id="r_a2d6e86f4ff2db447c525e82b88d3173e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#a2d6e86f4ff2db447c525e82b88d3173e">sstr_printf_append</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> buf, const char *fmt,...)</td></tr>
<tr class="memdesc:a2d6e86f4ff2db447c525e82b88d3173e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="sstr_8h.html#ab2d845cc91a348545e8f6b375437de6b" title="Create formatted string (printf-style with extensions)">sstr_printf()</a>, but but print to <em>buf</em> instead of create a new one.  <br /></td></tr>
<tr class="separator:a2d6e86f4ff2db447c525e82b88d3173e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5dc9a3c19614c5cec61b530762c8af" id="r_afa5dc9a3c19614c5cec61b530762c8af"><td class="memItemLeft" align="right" valign="top"><a id="afa5dc9a3c19614c5cec61b530762c8af" name="afa5dc9a3c19614c5cec61b530762c8af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sstr_append_int_str</b> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, int i)</td></tr>
<tr class="memdesc:afa5dc9a3c19614c5cec61b530762c8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert sstr &lt;-&gt; int,long,float,double <br /></td></tr>
<tr class="separator:afa5dc9a3c19614c5cec61b530762c8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3ffef62210a36405f2435ee4dc10aa" id="r_a3c3ffef62210a36405f2435ee4dc10aa"><td class="memItemLeft" align="right" valign="top"><a id="a3c3ffef62210a36405f2435ee4dc10aa" name="a3c3ffef62210a36405f2435ee4dc10aa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sstr_parse_long</b> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, long *v)</td></tr>
<tr class="separator:a3c3ffef62210a36405f2435ee4dc10aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf59c981c9c6603f54a6d63ed50411f" id="r_adaf59c981c9c6603f54a6d63ed50411f"><td class="memItemLeft" align="right" valign="top"><a id="adaf59c981c9c6603f54a6d63ed50411f" name="adaf59c981c9c6603f54a6d63ed50411f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sstr_parse_int</b> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> *s, int *v)</td></tr>
<tr class="separator:adaf59c981c9c6603f54a6d63ed50411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ee8186100ac02b9e14b0c66bb739c" id="r_a7d8ee8186100ac02b9e14b0c66bb739c"><td class="memItemLeft" align="right" valign="top"><a id="a7d8ee8186100ac02b9e14b0c66bb739c" name="a7d8ee8186100ac02b9e14b0c66bb739c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sstr_append_long_str</b> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, long l)</td></tr>
<tr class="separator:a7d8ee8186100ac02b9e14b0c66bb739c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ddf1f3fe7fc4448a4137157e42aa2f" id="r_a79ddf1f3fe7fc4448a4137157e42aa2f"><td class="memItemLeft" align="right" valign="top"><a id="a79ddf1f3fe7fc4448a4137157e42aa2f" name="a79ddf1f3fe7fc4448a4137157e42aa2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sstr_append_float_str</b> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, float f, int precission)</td></tr>
<tr class="separator:a79ddf1f3fe7fc4448a4137157e42aa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc643913e16315be6847da9b19e4664" id="r_a8dc643913e16315be6847da9b19e4664"><td class="memItemLeft" align="right" valign="top"><a id="a8dc643913e16315be6847da9b19e4664" name="a8dc643913e16315be6847da9b19e4664"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sstr_append_double_str</b> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, double f, int precision)</td></tr>
<tr class="separator:a8dc643913e16315be6847da9b19e4664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6f5b951022c69805506e4419c61f2b" id="r_a5e6f5b951022c69805506e4419c61f2b"><td class="memItemLeft" align="right" valign="top"><a id="a5e6f5b951022c69805506e4419c61f2b" name="a5e6f5b951022c69805506e4419c61f2b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sstr_parse_double</b> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, double *v)</td></tr>
<tr class="separator:a5e6f5b951022c69805506e4419c61f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d78409e863e5c0ba6da2ffbdcc4ff2b" id="r_a2d78409e863e5c0ba6da2ffbdcc4ff2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#a2d78409e863e5c0ba6da2ffbdcc4ff2b">sstr_append_of_if</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, const void *data, size_t length, int cond)</td></tr>
<tr class="memdesc:a2d78409e863e5c0ba6da2ffbdcc4ff2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append if cond is true, otherwise do nothing.  <br /></td></tr>
<tr class="separator:a2d78409e863e5c0ba6da2ffbdcc4ff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b300c1b39752d5cddd73689320040b6" id="r_a7b300c1b39752d5cddd73689320040b6"><td class="memItemLeft" align="right" valign="top"><a id="a7b300c1b39752d5cddd73689320040b6" name="a7b300c1b39752d5cddd73689320040b6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sstr_json_escape_string_append</b> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> out, <a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> in)</td></tr>
<tr class="separator:a7b300c1b39752d5cddd73689320040b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1c074e4c7d2d69a4f3c9f52c8600f6" id="r_abd1c074e4c7d2d69a4f3c9f52c8600f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#abd1c074e4c7d2d69a4f3c9f52c8600f6">sstr_append_indent</a> (<a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> s, size_t indent)</td></tr>
<tr class="memdesc:abd1c074e4c7d2d69a4f3c9f52c8600f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">append spaces at the end of the sstr_t.  <br /></td></tr>
<tr class="separator:abd1c074e4c7d2d69a4f3c9f52c8600f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129613e5c78d5c74439c8abb917234e1" id="r_a129613e5c78d5c74439c8abb917234e1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sstr_8h.html#a129613e5c78d5c74439c8abb917234e1">sstr_version</a> (void)</td></tr>
<tr class="memdesc:a129613e5c78d5c74439c8abb917234e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return version string.  <br /></td></tr>
<tr class="separator:a129613e5c78d5c74439c8abb917234e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>sstr_t are objects that represent sequences of characters. </p>
<p>The standard C style string is a sequence of characters terminated by a null character, which is easy to cause buffer overflow. And it's annoying to pass pointer and length of string to every whare.</p>
<p>The sequence of characters just like a string in C++, inside the sstr_t struct, it also has a null character at the end, so that we can use sstr_t as a C style string.</p>
<p>sstr_t contains a pointer to char sequence and its length, solves the security problems of standard C string. With functions bundle with sstr_t, you can easily manipulate the string just like standard C string, but in a safer way: </p><pre class="fragment">sstr_t stotal = sstr_new();
sstr_t s1 = sstr("hello");
sstr_t s2 = sstr("world");
sstr_append(stotal, s1);
sstr_append_of(stotal, " ", 1);
sstr_append(stotal, s2);
sstr_free(s1);
sstr_free(s2);

sstr_t result = sstr_printf("stotal=%S, c-str=%s, int=%d, long=%ld",
    stotal, stotal, 123, (long)456);

puts(sstr_cstr(result));

sstr_free(result);
sstr_free(stotal);
</pre> </div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad5290253c7b53c6a66ed07b782f68714" name="ad5290253c7b53c6a66ed07b782f68714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5290253c7b53c6a66ed07b782f68714">&#9670;&#160;</a></span>sstr_append_cstr_if</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sstr_append_cstr_if</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cond&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    <a class="el" href="sstr_8c.html#a2d78409e863e5c0ba6da2ffbdcc4ff2b">sstr_append_of_if</a>(dst, src, strlen(src), cond)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append C style string if cond is true, otherwise do nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination sstr_t to append to. </td></tr>
    <tr><td class="paramname">src</td><td>source C-style string to append </td></tr>
    <tr><td class="paramname">cond</td><td>condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f83884713d44719070e83e62639716c" name="a7f83884713d44719070e83e62639716c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f83884713d44719070e83e62639716c">&#9670;&#160;</a></span>sstr_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sstr_length</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;((struct <a class="el" href="structsstr__s.html">sstr_s</a>*)s)-&gt;length</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the length of <em>s</em>, in terms of bytes. </p>
<p>This is the number of actual bytes that conform the contents of the sstr_t, which is not necessarily equal to its storage capacity.</p>
<p>Note that sstr_t objects handle bytes without knowledge of the encoding that may eventually be used to encode the characters it contains. Therefore, the value returned may not correspond to the actual number of encoded characters in sequences of multi-byte or variable-length characters (such as UTF-8).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>sstr_t instance to get length of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes of <em>s</em>. </dd></dl>

</div>
</div>
<a id="afdb2acea9cceef81b1749f5604483b54" name="afdb2acea9cceef81b1749f5604483b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb2acea9cceef81b1749f5604483b54">&#9670;&#160;</a></span>SSTR_TYPE_LONG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SSTR_TYPE_LONG&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>String stored in heap-allocated buffer </p>

</div>
</div>
<a id="ac08dcbb7318a37aaebc120173cdc0b9b" name="ac08dcbb7318a37aaebc120173cdc0b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08dcbb7318a37aaebc120173cdc0b9b">&#9670;&#160;</a></span>SSTR_TYPE_REF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SSTR_TYPE_REF&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>String references external data (zero-copy) </p>

</div>
</div>
<a id="a02b26ce895798f7fd4df3d6e40b0afad" name="a02b26ce895798f7fd4df3d6e40b0afad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b26ce895798f7fd4df3d6e40b0afad">&#9670;&#160;</a></span>SSTR_TYPE_SHORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SSTR_TYPE_SHORT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>String stored inline (up to 25 chars) </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa3b3c1563041f1323542f3e84f7817b1" name="aa3b3c1563041f1323542f3e84f7817b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b3c1563041f1323542f3e84f7817b1">&#9670;&#160;</a></span>sstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> sstr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a sstr_t from C-style (NULL-terminated) string <em>str</em>. </p>
<p>The <em>cstr</em> is copied to the new sstr_t, so you can free <em>cstr</em> after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cstr</td><td>C-style string to copy to the result sstr_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sstr_t containing <em>data</em> copied from cstr.</dd></dl>
<p>Create a sstr_t from C-style (NULL-terminated) string <em>str</em>.</p>
<p>Convenience function that creates an sstr_t from a standard C string. Automatically calculates length using strlen() and copies the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cstr</td><td>Null-terminated C string to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New sstr_t containing a copy of the string </dd></dl>

</div>
</div>
<a id="ad8eb5ed3acc6d1f90c5097ab2f62672f" name="ad8eb5ed3acc6d1f90c5097ab2f62672f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8eb5ed3acc6d1f90c5097ab2f62672f">&#9670;&#160;</a></span>sstr_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sstr_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append one sstr_t to another. </p>
<p>Concatenates two sstr_t strings efficiently. Automatically handles all storage type combinations and capacity management.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Destination sstr_t to extend </td></tr>
    <tr><td class="paramname">src</td><td>Source sstr_t to append </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>dst is modified, src is unchanged </dd>
<dd>
dst cannot be REF type </dd></dl>

</div>
</div>
<a id="aa0985a798ff952a68046fb594d2f3d27" name="aa0985a798ff952a68046fb594d2f3d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0985a798ff952a68046fb594d2f3d27">&#9670;&#160;</a></span>sstr_append_cstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sstr_append_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append C string to sstr_t. </p>
<p>Convenience function to append a null-terminated C string. Calculates length automatically and appends the string data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Destination sstr_t to extend </td></tr>
    <tr><td class="paramname">src</td><td>Source C string (null-terminated) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>More efficient than creating a temporary sstr_t </dd>
<dd>
dst cannot be REF type </dd></dl>

</div>
</div>
<a id="abd1c074e4c7d2d69a4f3c9f52c8600f6" name="abd1c074e4c7d2d69a4f3c9f52c8600f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1c074e4c7d2d69a4f3c9f52c8600f6">&#9670;&#160;</a></span>sstr_append_indent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sstr_append_indent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>append spaces at the end of the sstr_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the sstr_t to append spaces to. </td></tr>
    <tr><td class="paramname">indent</td><td>numbers of spaces to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab55b8f697e21006921e191ca25dbcec5" name="ab55b8f697e21006921e191ca25dbcec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55b8f697e21006921e191ca25dbcec5">&#9670;&#160;</a></span>sstr_append_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sstr_append_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append raw data to string. </p>
<p>Extends the string by appending arbitrary byte data. The most flexible append function, works with any data including embedded nulls. Handles storage type transitions automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Destination sstr_t to extend </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to data to append (can contain null bytes) </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to append from data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Automatically manages capacity and storage type </dd>
<dd>
Cannot be called on REF type strings </dd></dl>

</div>
</div>
<a id="a2d78409e863e5c0ba6da2ffbdcc4ff2b" name="a2d78409e863e5c0ba6da2ffbdcc4ff2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d78409e863e5c0ba6da2ffbdcc4ff2b">&#9670;&#160;</a></span>sstr_append_of_if()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sstr_append_of_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append if cond is true, otherwise do nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the sstr_t to append to. </td></tr>
    <tr><td class="paramname">data</td><td>data to append. </td></tr>
    <tr><td class="paramname">length</td><td>length of <em>data</em>. </td></tr>
    <tr><td class="paramname">cond</td><td>condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affb41a505a69f235d647bec5f96165f8" name="affb41a505a69f235d647bec5f96165f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb41a505a69f235d647bec5f96165f8">&#9670;&#160;</a></span>sstr_append_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sstr_append_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append zero bytes to string (for buffer allocation) </p>
<p>Extends the string by appending the specified number of null bytes. Automatically handles storage type transitions and capacity management. Useful for pre-allocating buffer space before reading data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Destination sstr_t to extend </td></tr>
    <tr><td class="paramname">length</td><td>Number of null bytes to append </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Will convert SHORT to LONG type if needed </dd>
<dd>
Cannot be called on REF type strings </dd></dl>

</div>
</div>
<a id="acb1410073b28bea451ab0be874d5875b" name="acb1410073b28bea451ab0be874d5875b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1410073b28bea451ab0be874d5875b">&#9670;&#160;</a></span>sstr_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sstr_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear string content to empty. </p>
<p>Resets the string to empty (length 0) without deallocating memory. The string can be reused efficiently after clearing. For SHORT and LONG types, sets length to 0 and adds null terminator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>sstr_t instance to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does not free allocated memory, only resets length </dd>
<dd>
Does nothing for REF type strings </dd>
<dd>
After clearing, the string is reusable</dd></dl>
<p>Clear string content to empty.</p>
<p>Resets the string to empty state without deallocating memory. For SHORT and LONG types, sets length to 0 and adds null terminator. For REF type, does nothing as it references external data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does not free allocated memory, just marks string as empty </dd>
<dd>
After clearing, the string can be reused efficiently </dd></dl>

</div>
</div>
<a id="ad27f624aa62f1f648e96cc195da7412f" name="ad27f624aa62f1f648e96cc195da7412f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27f624aa62f1f648e96cc195da7412f">&#9670;&#160;</a></span>sstr_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sstr_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <em>a</em> and <em>b</em> return 0 if equal, &lt;0 if <em>a</em> &lt; <em>b</em>, &gt;0 if <em>a</em> &gt; <em>b</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>sstr_t to be compared. </td></tr>
    <tr><td class="paramname">b</td><td>sstr_t to be compared to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int the compare result. </dd>
<dd>
0 They compare equal. </dd>
<dd>
&lt;0 Either the value of the first character that does not match is lower in the compared string, or all compared characters match but the compared string is shorter. </dd>
<dd>
&gt;0 Either the value of the first character that does not match is greater in the compared string, or all compared characters match but the compared string is longer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is case sensitive.</dd></dl>
<p>Compare <em>a</em> and <em>b</em> return 0 if equal, &lt;0 if <em>a</em> &lt; <em>b</em>, &gt;0 if <em>a</em> &gt; <em>b</em>.</p>
<p>Compares two strings byte-by-byte. Handles NULL values gracefully. Uses the same comparison semantics as strcmp().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First string to compare </td></tr>
    <tr><td class="paramname">b</td><td>Second string to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 if a&lt;b, 0 if a==b, &gt;0 if a&gt;b </dd></dl>
<dl class="section note"><dt>Note</dt><dd>NULL is considered less than any non-NULL string </dd>
<dd>
Two NULL strings are considered equal </dd></dl>

</div>
</div>
<a id="a4925de2352444a8822843cbbac5ae3ed" name="a4925de2352444a8822843cbbac5ae3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4925de2352444a8822843cbbac5ae3ed">&#9670;&#160;</a></span>sstr_compare_c()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sstr_compare_c </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare sstr_t <em>a</em> and <em>c-style</em> string b </p>
<p>just like sstr_compare, but compare <em>a</em> and <em>c-style</em> string b.</p>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="af45cbd228a22432910527e63c4b26b3b" name="af45cbd228a22432910527e63c4b26b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45cbd228a22432910527e63c4b26b3b">&#9670;&#160;</a></span>sstr_cstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * sstr_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return C-style string representation of <em>s</em>. </p>
<p>This function return a pointer to the internal C-style string, it has a null-terminal character at the end. So you can use it as a C-style string. The returned pointer is valid until <a class="el" href="sstr_8h.html#ae99d652d5a9d25fc79343d2ac18cb0e5" title="delete a sstr_t.">sstr_free()</a>/sstr_append()/sstr_append_of() or any functions that may modify the contents of sstr_t is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>sstr_t instance to convert to C-style string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* C-style string representation of <em>s</em>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned string is reused by <em>s</em>, do not free it yourself.</dd></dl>
<p>Return C-style string representation of <em>s</em>.</p>
<p>Returns a pointer to the null-terminated character array. This allows sstr_t strings to be used with standard C string functions. The pointer remains valid until the sstr_t is modified or freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The sstr_t string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to null-terminated character array </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned pointer should not be freed directly </dd></dl>

</div>
</div>
<a id="a87e2708071bfb86f3961788466c9192f" name="a87e2708071bfb86f3961788466c9192f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e2708071bfb86f3961788466c9192f">&#9670;&#160;</a></span>sstr_dup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> sstr_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate <em>s</em> and return. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>sstr_t to duplicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sstr_t duplicate of <em>s</em>. </dd></dl>

</div>
</div>
<a id="ae99d652d5a9d25fc79343d2ac18cb0e5" name="ae99d652d5a9d25fc79343d2ac18cb0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99d652d5a9d25fc79343d2ac18cb0e5">&#9670;&#160;</a></span>sstr_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sstr_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delete a sstr_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>sstr_t instance to delete.</td></tr>
  </table>
  </dd>
</dl>
<p>delete a sstr_t.</p>
<p>Properly deallocates all memory associated with an sstr_t string. For LONG type strings, frees the dynamically allocated buffer first. For REF type strings, does not free the referenced data (caller's responsibility). Safe to call with NULL pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The sstr_t string to free (can be NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63e859888a3565efeac6f513cadc239e" name="a63e859888a3565efeac6f513cadc239e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e859888a3565efeac6f513cadc239e">&#9670;&#160;</a></span>sstr_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> sstr_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty sstr_t. </p>
<dl class="section return"><dt>Returns</dt><dd>sstr_t</dd></dl>
<p>Create an empty sstr_t.</p>
<p>Allocates memory for a new sstr_t structure and initializes it to an empty string. The string starts in SHORT mode, which is optimized for strings up to 25 characters.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to newly allocated sstr_t, caller must free with <a class="el" href="sstr_8h.html#ae99d652d5a9d25fc79343d2ac18cb0e5" title="delete a sstr_t.">sstr_free()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always check for NULL return value in production code </dd></dl>

</div>
</div>
<a id="ad61027cdd29e89a0a946740cc04fcba2" name="ad61027cdd29e89a0a946740cc04fcba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61027cdd29e89a0a946740cc04fcba2">&#9670;&#160;</a></span>sstr_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> sstr_of </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a sstr_t from <em>data</em> with <em>length</em> bytes. </p>
<p>The <em>data</em> is copied to the new sstr_t, so you can free <em>data</em> after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data to copy to the result sstr_t. </td></tr>
    <tr><td class="paramname">length</td><td>length of <em>data</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sstr_t containing data copied from <em>data</em>.</dd></dl>
<p>Create a sstr_t from <em>data</em> with <em>length</em> bytes.</p>
<p>Creates a new sstr_t by copying the specified number of bytes from the source data. Automatically chooses SHORT or LONG storage based on the length. This is the most flexible constructor function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Source data buffer to copy from </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New sstr_t containing a copy of the data</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If length &lt;= 25, uses SHORT storage (no heap allocation for data) </dd>
<dd>
If length &gt; 25, uses LONG storage (separate heap allocation) </dd>
<dd>
Always adds null terminator for C string compatibility </dd></dl>

</div>
</div>
<a id="ab2d845cc91a348545e8f6b375437de6b" name="ab2d845cc91a348545e8f6b375437de6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d845cc91a348545e8f6b375437de6b">&#9670;&#160;</a></span>sstr_printf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> sstr_printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create formatted string (printf-style with extensions) </p>
<p>Creates a new sstr_t by formatting the provided arguments according to the format string. Supports all standard printf formats plus extended specifiers like S for sstr_t.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>Format string (supports extended specifiers) </td></tr>
    <tr><td class="paramname">...</td><td>Variable arguments matching format specifiers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New sstr_t containing formatted result </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Caller must free the returned sstr_t with <a class="el" href="sstr_8h.html#ae99d652d5a9d25fc79343d2ac18cb0e5" title="delete a sstr_t.">sstr_free()</a> </dd></dl>

</div>
</div>
<a id="a2d6e86f4ff2db447c525e82b88d3173e" name="a2d6e86f4ff2db447c525e82b88d3173e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6e86f4ff2db447c525e82b88d3173e">&#9670;&#160;</a></span>sstr_printf_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> sstr_printf_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="sstr_8h.html#ab2d845cc91a348545e8f6b375437de6b" title="Create formatted string (printf-style with extensions)">sstr_printf()</a>, but but print to <em>buf</em> instead of create a new one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to print to. </td></tr>
    <tr><td class="paramname">fmt</td><td>format string. </td></tr>
    <tr><td class="paramname">...</td><td>arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sstr_t the result string. </dd></dl>

</div>
</div>
<a id="aadff88bf80c9a1d4b2911f9f19aceb03" name="aadff88bf80c9a1d4b2911f9f19aceb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadff88bf80c9a1d4b2911f9f19aceb03">&#9670;&#160;</a></span>sstr_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> sstr_ref </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a sstr_t from data with length bytes. The data is not copied, but have a pointer to data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data of the result sstr_t. </td></tr>
    <tr><td class="paramname">length</td><td>length of <em>data</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sstr_t </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result sstr_t does not own data, but have a pointer to data. It is a reference, not a copy. </dd>
<dd>
You cannot append a <a class="el" href="sstr_8h.html#aadff88bf80c9a1d4b2911f9f19aceb03" title="Create a sstr_t from data with length bytes. The data is not copied, but have a pointer to data.">sstr_ref()</a> result.</dd></dl>
<p>Create a sstr_t from data with length bytes. The data is not copied, but have a pointer to data.</p>
<p>Creates an sstr_t that references external data without copying. This is efficient for temporary strings or when you want to avoid copying large buffers. The referenced data must remain valid for the lifetime of the sstr_t.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to external data buffer </td></tr>
    <tr><td class="paramname">length</td><td>Length of the referenced data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New sstr_t that references the data (REF type)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The referenced data must not be freed while the sstr_t exists </dd>
<dd>
Modifying operations will fail on REF type strings </dd></dl>
<dl class="section note"><dt>Note</dt><dd>No memory is allocated for the data itself, only the sstr_t structure </dd></dl>

</div>
</div>
<a id="a5ba343262041c4dc26b5c218c4cc9cb3" name="a5ba343262041c4dc26b5c218c4cc9cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba343262041c4dc26b5c218c4cc9cb3">&#9670;&#160;</a></span>sstr_substr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> sstr_substr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get substring of <em>s</em> starting at <em>index</em> with <em>length</em> bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>sstr_t instance to get substring of. </td></tr>
    <tr><td class="paramname">index</td><td>index of the first byte of the substring. </td></tr>
    <tr><td class="paramname">len</td><td>number of bytes of the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sstr_t substring of <em>s</em>. if <em>index</em> is out of range, return an empty string. </dd></dl>

</div>
</div>
<a id="a129613e5c78d5c74439c8abb917234e1" name="a129613e5c78d5c74439c8abb917234e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129613e5c78d5c74439c8abb917234e1">&#9670;&#160;</a></span>sstr_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * sstr_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return version string. </p>
<dl class="section return"><dt>Returns</dt><dd>const char* static version string. </dd></dl>

</div>
</div>
<a id="a024de0f2bca395ea91d6f8966adaedbe" name="a024de0f2bca395ea91d6f8966adaedbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024de0f2bca395ea91d6f8966adaedbe">&#9670;&#160;</a></span>sstr_vslprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> sstr_vslprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Printf-style formatting with extended format specifiers. </p>
<p>Creates a formatted string using printf-like syntax with additional format specifiers for sstr_t and other types. This is the va_list variant used by <a class="el" href="sstr_8h.html#ab2d845cc91a348545e8f6b375437de6b" title="Create formatted string (printf-style with extensions)">sstr_printf()</a> and <a class="el" href="sstr_8h.html#a2d6e86f4ff2db447c525e82b88d3173e" title="Same as sstr_printf(), but but print to buf instead of create a new one.">sstr_printf_append()</a>.</p>
<p>Supported format specifiers:</p><ul>
<li>%[0][width]T time_t value</li>
<li>%[0][width][u][x|X]z ssize_t/size_t</li>
<li>%[0][width][u][x|X]d int/unsigned int</li>
<li>%[0][width][u][x|X]l long</li>
<li>%[0][width][u][x|X]D int32_t/uint32_t</li>
<li>%[0][width][u][x|X]L int64_t/uint64_t</li>
<li>%[0][width][.width]f double (max %18.15f)</li>
<li>p void * pointer</li>
<li>%[x|X]S sstr_t (x/X for hexadecimal)</li>
<li>s null-terminated C string</li>
<li>%*s length and string pointer</li>
<li>Z null character '\0'</li>
<li>N newline '<br  />
'</li>
<li>c single character</li>
<li>%% literal % character</li>
</ul>
<p>Reserved:</p><ul>
<li>C wide character (wchar_t)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>Format string with specifiers </td></tr>
    <tr><td class="paramname">args</td><td>va_list of arguments matching format specifiers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New sstr_t containing formatted result </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If u/x/X used, trailing 'd' can be omitted </dd></dl>

</div>
</div>
<a id="ad64cf287e39b67b4bf945b5f5344562e" name="ad64cf287e39b67b4bf945b5f5344562e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64cf287e39b67b4bf945b5f5344562e">&#9670;&#160;</a></span>sstr_vslprintf_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a> sstr_vslprintf_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sstr_8h.html#a8d28a1ce0ac6dd8b8e50af6f78e735e7">sstr_t</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append formatted text to existing string (va_list version) </p>
<p>Like sstr_vslprintf but appends to an existing string instead of creating a new one. More efficient when building strings incrementally. Uses the same extended format specifiers as sstr_vslprintf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Existing sstr_t to append formatted text to </td></tr>
    <tr><td class="paramname">fmt</td><td>Format string with specifiers </td></tr>
    <tr><td class="paramname">args</td><td>va_list of arguments matching format specifiers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same buf pointer (for method chaining) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>buf cannot be REF type </dd>
<dd>
Returns NULL on formatting error </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_313caf1132e152dd9b58bea13a4052ca.html">utils</a></li><li class="navelem"><a class="el" href="sstr_8h.html">sstr.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
